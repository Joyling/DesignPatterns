<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>高阶函数的应用</title>
</head>

<body>
    <script>
        // 函数柯里化
        var currying = function (fn) {
            var args = [];
            return function () {
                if (arguments.length === 0) {
                    return fn.apply(this, args);
                } else {
                    [].push.apply(args, arguments);
                    return arguments.callee
                }
            }
        }

        var cost = (function () {
            var money = 0;
            return function () {
                for (var i = 0; i < arguments.length; i++) {
                    money += arguments[i]
                }
                return money;
            }
        })()

        var cost = currying(cost);
        cost(100);
        cost(200);
        cost(300);
        cost(100)(100)
        cost();

        // 函数去柯里化
        Function.prototype.uncurrying = function() {
            var self = this;
            return function() {
                var obj = Array.prototype.shift.call(arguments);
                return self.apply(obj, arguments)
            }
        }

        var push = Array.prototype.push.uncurrying();
        (function() {
            push(arguments, 4);
            console.log(arguments)
        })(1,2,3)

        // 函数节流
        var throttle = function(fn, interval) {
            var timer, firstTime = true, __self = fn; // 保存需要被延迟执行的函数引用
            return function() {
                var __me = this, args = arguments;
                if(firstTime) {
                    __self.apply(__me, args);
                    return false;
                }
                if(timer) { // 如果定时器还在，说明前一次延迟执行还没有完成
                    return false
                }
                timer = setTimeout(() => {
                    clearTimeout(timer);
                    timer = null;
                    __self.apply(__me, args);
                }, interval || 500);
            }
        }
        window.onresize = throttle(function() {
            console.log(1)
        }, 500)


        // 分时函数
        // ary: 创建节点时需要的数据，fn：封装了创建节点逻辑的函数 count： 每一批创建的节点数量
        var timeChunk = function(ary, fn, count) {  
            var obj, t;
            var len = ary.length;
            var start = function() {
                for(var i = 0; i < Math.min(count || 1, ary.length); i++) {
                    var obj = ary.shift();
                    fn(obj)
                }
            }
            return function() {
                t = setInterval(() => {
                    if(ary.length === 0) { // 如果全部节点都已经被创建好
                        return clearInterval(t);
                    }
                    start();
                }, 200); // 分批执行的时间间隔，也可以用参数的形式传入
            }
        }

        var ary = [];
        for(var i = 1; i <= 1000; i++) {
            ary.push(i);
        }
        var renderFriendList = timeChunk(ary, function(n) {
            var div = document.createElement('div');
            div.innerHTML = n;
            document.body.appendChild(div);
        }, 8);
        renderFriendList();
    </script>
</body>

</html>